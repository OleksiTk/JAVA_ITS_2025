# Ткаченко Олексій ЦК-31 ПЗ-8

<p style="text-align: center; font-size:25px">Відповідь на контрольні питання</p>

## **1. Чим інтерфейс `Set` відрізняється від інтерфейсів `Collection` та `List`?**

- `Collection` — базовий інтерфейс усіх колекцій.
- `List` — впорядкована колекція, допускає дублікатів, елементи мають індекси.
- `Set` — **множина без дублікатів**, порядок зберігання не гарантується.

**Коротко:**
`List` → порядок + індекси + дублікати
`Set` → жодних дублікатів, порядок не важливий
`Collection` → найзагальніший предок, сам не накладає обмежень

---

## **2. Чим `HashSet` відрізняється від `TreeSet`?**

| Властивість         | HashSet                   | TreeSet                                                    |
| ------------------- | ------------------------- | ---------------------------------------------------------- |
| Порядок             | Не гарантується           | Відсортований                                              |
| Швидкість           | Дуже швидкий (O(1))       | Повільніший (O(log n))                                     |
| Вимоги до елементів | `equals()` + `hashCode()` | Елементи мають бути **Comparable** або передати Comparator |
| Структура           | Хеш-таблиця               | Червоний-чорний дерево                                     |

---

## **3. Що таке хешування, хеш, хеш-код, хеш-функція?**

- **Хешування** — перетворення об’єкта в число (хеш-код).
- **Хеш** або **хеш-код** — число (int), результат хеш-функції.
- **Хеш-функція** — функція, яка з об’єкта обчислює хеш-код.
- Використовується в HashSet/HashMap для швидкого пошуку.

---

## **4. Яким вимогам має відповідати коректна хеш-функція?**

1. Якщо `a.equals(b) == true`, то їхні хеш-коди **мають бути рівні**.
2. Якщо об’єкти не рівні, хеш-коди **можуть** збігатися (колізії дозволені).
3. Під час життя об’єкта його хеш-код **не повинен змінюватися**.

---

## **5. Які властивості притаманні хорошій хеш-функції?**

- Мінімізує колізії.
- Рівномірно розподіляє об’єкти по бакетах.
- Швидка у виконанні.
- Стабільна (не змінюється протягом життя об’єкта).

---

## **6. Якими критеріям мають відповідати об’єкти для зберігання у `HashSet`?**

1. **Коректна реалізація `equals()` і `hashCode()`**.
2. Хеш-код не повинен змінюватися під час перебування в множині (об’єкт має бути **іммутабельним** або поводитись як такий).

---

## **7. Переваги/недоліки `HashSet` у порівнянні з `TreeSet`**

### **Переваги HashSet:**

- Найшвидший: O(1)
- Менше памʼяті
- Не вимагає Comparable

### **Недоліки HashSet:**

- Немає сортування
- Порядок елементів випадковий

### **Переваги TreeSet:**

- Автоматично сортує
- Можна створити власний Comparator

### **Недоліки TreeSet:**

- Повільніший: O(log n)
- Елементи мають реалізовувати Comparable або мати Comparator

---

## **8. Чим поняття `size` відрізняється від `capacity`?**

- **size** — фактична кількість елементів.
- **capacity** — обсяг внутрішнього масиву (скільки елементів можна помістити без розширення).

### Чи може `size > capacity`?

НІ, ніколи.

### Чи може `capacity > size`?

Так, завжди — коли структура має вільне місце.

Наприклад, у ArrayList `capacity` розширюється при додаванні елементів.

---

## **9. Що таке `load factor` і як він впливає?**

**Load factor (коефіцієнт заповнення)** — коли хеш-таблиця заповнюється до певного рівня, вона автоматично розширюється (rehash).

Стандартне значення: **0.75**

Це означає:

Якщо кількість елементів перевищує 75% capacity → хеш-таблиця збільшується вдвічі.

Впливає на:

- продуктивність,
- кількість колізій,
- памʼять.

---

## **10. Що таке асоціативний масив? Чим ключ відрізняється від значення?**

**Асоціативний масив (Map)** — структура даних _ключ → значення_.

- **Ключ** — унікальний, визначає доступ до значення.
- **Значення** — може повторюватися.

---

## **11. Чи може в асоціативному масиві бути кілька однакових ключів або значень?**

- **Однакові ключі → НІ**. Ключі унікальні: новий ключ перезаписує старе значення.
- **Однакові значення → ТАК**, значення можуть дублюватися.

---

## **12. Наслідки зберігання _неімутабельних_ об’єктів у HashSet / HashMap**

### Якщо об’єкт-ключ змінюється після вставки:

- Його `hashCode()` змінюється.
- Об’єкт "втрачається" — знайти його неможливо.
- HashSet може містити дублікати.
- У HashMap не можна отримати значення по ключу.

**Висновок:**
Ключі повинні бути **іммутабельними** або не змінювати поля, що впливають на `equals()`/`hashCode()`.

Значення у HashMap можуть бути будь-які — для них це **безпечно**.

---

## **13. Чи можуть об’єкти без Comparable зберігатись у TreeMap?**

**НІ**, якщо не передано Comparator.

TreeMap потребує **порівняння ключів**:

- або ключ реалізує `Comparable`,
- або передано `Comparator` у конструкторі.

---

## **14. Чи можуть об’єкти без Comparable зберігатись у HashMap?**

Так, можуть.

`HashMap` працює тільки з:

- `equals()`
- `hashCode()`

Інтерфейс `Comparable` йому **не потрібен**.

### Чи впливає `Comparable` на роботу HashMap?

Ні, жодним чином.

---
